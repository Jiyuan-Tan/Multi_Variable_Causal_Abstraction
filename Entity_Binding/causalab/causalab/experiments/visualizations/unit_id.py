"""
Shared unit ID parsing utilities for visualization modules.

This module provides common functions for extracting information from unit ID strings
generated by model units (AttentionHead, ResidualStream, MLP).

Unit ID formats:
- AttentionHead(Layer-2,Head-5,Token-last_token)
- ResidualStream(Layer-5,block_output,Token-last_token)
- MLP(Layer-3,mlp_output,Token-last_token)
"""

from typing import Any, Dict, List, Optional, Tuple, Union, cast
import re


# =============================================================================
# Type Aliases
# =============================================================================

# Feature indices for single mode: unit_id -> feature indices
FeatureIndicesSingle = Dict[str, Optional[List[int]]]

# Feature indices for per-layer mode: layer -> {unit_id -> feature indices}
FeatureIndicesPerLayer = Dict[int, Dict[str, Optional[List[int]]]]

# Union type for both modes
FeatureIndicesUnion = Union[FeatureIndicesSingle, FeatureIndicesPerLayer]


# =============================================================================
# Unit ID Parsing Functions
# =============================================================================


def extract_layer_from_unit_id(unit_id: str) -> int:
    """
    Extract layer number from a unit ID string.

    Handles formats like:
    - "ResidualStream(Layer-5,...)"
    - "MLP(Layer-3,...)"
    - "AttentionHead(Layer-2,Head-5,...)"

    Args:
        unit_id: Unit ID string.

    Returns:
        Layer number as integer.

    Raises:
        ValueError: If layer cannot be parsed from unit_id.
    """
    match = re.search(r"Layer-(\d+)", unit_id)
    if not match:
        raise ValueError(
            f"Could not parse layer from unit_id: {unit_id}. "
            f"Expected format containing 'Layer-X'"
        )
    return int(match.group(1))


def extract_token_position_from_unit_id(unit_id: str) -> str:
    """
    Extract token position ID from a unit ID string.

    Handles formats like:
    - "ResidualStream(Layer-5,block_output,Token-last_token)"
    - "MLP(Layer-3,mlp_output,Token-last_token)"

    Args:
        unit_id: Unit ID string.

    Returns:
        Token position ID as string.

    Raises:
        ValueError: If token position cannot be parsed from unit_id.
    """
    match = re.search(r"Token-([^)]+)", unit_id)
    if not match:
        raise ValueError(
            f"Could not parse token position from unit_id: {unit_id}. "
            f"Expected format containing 'Token-<token_position_id>'"
        )
    return match.group(1)


def extract_layer_head_from_unit_id(unit_id: str) -> Tuple[int, int]:
    """
    Extract (layer, head) from an AttentionHead unit ID string.

    Args:
        unit_id: Unit ID string like "AttentionHead(Layer-2,Head-5,...)"

    Returns:
        Tuple of (layer, head) as integers.

    Raises:
        ValueError: If layer and head cannot be parsed from unit_id.
    """
    match = re.search(r"Layer-(\d+),Head-(\d+)", unit_id)
    if not match:
        raise ValueError(
            f"Could not parse layer and head from unit_id: {unit_id}. "
            f"Expected format: 'AttentionHead(Layer-X,Head-Y,...)'"
        )
    return int(match.group(1)), int(match.group(2))


# =============================================================================
# Component Type Detection
# =============================================================================


def detect_component_type(feature_indices: FeatureIndicesUnion) -> str:
    """
    Infer component type from unit IDs in feature_indices.

    Args:
        feature_indices: Either:
            - Dict[str, Optional[List[int]]] for single mode
            - Dict[int, Dict[str, Optional[List[int]]]] for per-layer mode

    Returns:
        One of: "attention_head", "residual_stream", "mlp"

    Raises:
        ValueError: If component type cannot be determined
    """
    if not feature_indices:
        raise ValueError("feature_indices is empty, cannot detect component type")

    first_key = next(iter(feature_indices.keys()))

    if isinstance(first_key, int):
        # Per-layer mode: Dict[int, Dict[str, ...]]
        per_layer_dict = cast(FeatureIndicesPerLayer, feature_indices)
        inner_dict = per_layer_dict[first_key]
        if not inner_dict:
            raise ValueError("Inner feature_indices dict is empty")
        unit_id = next(iter(inner_dict.keys()))
    else:
        # Single mode: Dict[str, ...]
        unit_id = first_key

    if "AttentionHead" in unit_id:
        return "attention_head"
    elif "ResidualStream" in unit_id:
        return "residual_stream"
    elif "MLP" in unit_id:
        return "mlp"
    else:
        raise ValueError(f"Unknown component type in unit_id: {unit_id}")


def is_per_layer_mode(feature_indices: FeatureIndicesUnion) -> bool:
    """
    Check if feature_indices is in per-layer mode (Dict[int, Dict]).

    Args:
        feature_indices: Feature indices dict (single or per-layer mode)

    Returns:
        True if per-layer mode, False if single mode.
    """
    if not feature_indices:
        return False
    first_key = next(iter(feature_indices.keys()))
    return isinstance(first_key, int)


def extract_grid_dimensions(
    component_type: str,
    feature_indices: FeatureIndicesUnion,
) -> Dict[str, Any]:
    """
    Extract grid dimensions (layers, heads, or token_positions) from unit IDs.

    Args:
        component_type: One of "attention_head", "residual_stream", "mlp"
        feature_indices: Feature indices dict (single or per-layer mode)

    Returns:
        Dict with grid dimensions:
        - attention_head: {"layers": [...], "heads": [...]}
        - residual_stream/mlp: {"layers": [...], "token_position_ids": [...]}
    """
    per_layer = is_per_layer_mode(feature_indices)

    # Collect all unit IDs
    all_unit_ids: List[str] = []
    if per_layer:
        per_layer_dict = cast(FeatureIndicesPerLayer, feature_indices)
        for layer_dict in per_layer_dict.values():
            all_unit_ids.extend(layer_dict.keys())
    else:
        single_dict = cast(FeatureIndicesSingle, feature_indices)
        all_unit_ids = list(single_dict.keys())

    if component_type == "attention_head":
        layers, heads = set(), set()
        for unit_id in all_unit_ids:
            if "AttentionHead" not in unit_id:
                continue
            try:
                layer, head = extract_layer_head_from_unit_id(unit_id)
                layers.add(layer)
                heads.add(head)
            except ValueError:
                continue
        return {"layers": sorted(layers), "heads": sorted(heads)}
    else:
        # residual_stream or mlp
        layers, positions = set(), set()
        component_marker = (
            "ResidualStream" if component_type == "residual_stream" else "MLP"
        )
        for unit_id in all_unit_ids:
            if component_marker not in unit_id:
                continue
            try:
                layer = extract_layer_from_unit_id(unit_id)
                position = extract_token_position_from_unit_id(unit_id)
                layers.add(layer)
                positions.add(position)
            except ValueError:
                continue
        return {"layers": sorted(layers), "token_position_ids": sorted(positions)}
